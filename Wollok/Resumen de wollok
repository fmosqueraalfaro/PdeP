Self
self es una manera con la cual el objeto se conoce a s√≠ mismo. Con self, puedo enviar mensajes que entienda el propio objeto, para poder abstraer l√≥gica repetida en otros m√©todos del mismo objeto. self es una referencia al mismo objeto.
Esto, con self, se puede resolver de la siguiente manera:
object camionDeVerduras {
  var kilometraje = 700000
  var cajones = 10

  method pesoCarga() = cajones * 50

  method velocidadMaxima() = 80 - self.pesoCarga() / 500
}
Hacemos el resto de los camiones, haciendo los m√©todos con las firmas necesarias (por ejemplo, recorrerRuta podr√≠a tener diferentes firmas y no estar en el scannion5000).
Polimorfismo
el polimorfismo en objetos es la capacidad de que un objeto pueda utilizar indistintamente a otros objetos, siendo que potencialmente estos otros sean distintos. Con esto en mente, deber√≠amos cambiar el m√©todo recorrerRuta en todos los camiones:
object camionDeVerduras {
	method recorrerRuta(extension, velocidad){
		kilometraje = kilometraje + extension
	}
}
object scanion5000 {
	method recorrerRuta(extension, velocidad){
		// no hace nada
	}
}

object camionCerealero {

	method recorrerRuta(extension, velocidad){
		nivelDeterioro += 0.max(velocidad - 45)
	}
}




Colecciones
‚Ä¢	listas: en donde los elementos tienen un orden y puede haber elementos repetidos. Se definen mediante el literal [ ], por ejemplo:
var bolsaDelSuper = [leche, manteca, jugo, jugo, jugo]
‚Ä¢	conjuntos: no hay orden en los elementos y no puede haber elementos repetidos. Se definen mediante el literal #{ } y tambi√©n son llamados sets, por ejemplo:
var numeros = #{1, 2, 3, 4}

Hicimos un ejercicio para conocer y practicar los mensajes que entienden las colecciones. Entre ellos estaban, size, add, remove, filter, map, forEach

¬øQu√© diferencia hay entre map y forEach? El primero lo usamos para devolver una lista y no queremos que haya efecto y el segundo para cuando queremos afectar a un conjunto de objetos.

Testing

describe "Test de mario" {

	test "Mario al evolucionar el ataque a bola de fuego" {
		
		mario.evolucionar()
		assert.equals("Bola de fuego", mario.ataque())

	}

	test "Mario al recibir un ataque se agota"{
		mario.recibirAtaque(200)
		assert.equals(200,mario.agotamiento())
}

	test "Mario descansa luego de un ataque"{
		mario.recibirAtaque(200)
		mario.descansar()
		assert.equals(0,mario.agotamiento())
	}

}




Clases
¬øC√≥mo hacemos para no repetir l√≥gica entre objetos que hacen las mismas cosas? üò© El paradigma orientado a objetos nos provee un mecanismo para resolver la repetici√≥n de comportamiento, ¬°las clases! üôå Gracias a este nuevo concepto podemos abstraer la l√≥gica repetida en un mismo ‚Äúmolde‚Äù para crear instancias a partir de √©l.
Es importante tener en cuenta que:
‚Ä¢	Todo objeto es siempre instancia de una y s√≥lo una clase.
‚Ä¢	No se puede cambiar la clase de un objeto en tiempo de ejecuci√≥n.
Mini machete
Todo el comportamiento:
‚Ä¢	En com√∫n, va en una superclase.
‚Ä¢	En espec√≠fico, va en la clase.
‚Ä¢	En com√∫n con la superclase pero que hace alguito m√°s, va redefinido con super en la clase.
‚Ä¢	Que no me dice qu√© hacer la superclase, lo defino como m√©todo abstracto en la super y luego lo redefino en clase.
Si tengo clases que:
‚Ä¢	Comparten solo mensajes en com√∫n, necesito una interfaz.
‚Ä¢	Adem√°s de los mensajes, tambi√©n comparten comportamiento, necesito una superclase.
Si tengo una clase que:
‚Ä¢	Provee comportamiento y mensajes sin comportamiento, es una clase abstracta.
‚Ä¢	Es todo comportamiento y no la quiero instanciar, es una clase abstracta.
‚Ä¢	Es todo comportamiento y la quiero instanciar, es una clase concreta.
Se puede heredar tanto de clases abstractas como de clases concretas.



Diagrama de clases
 
/'Para las clases polimorficas se usa, las interfaces son solo conjuntos de mensajes'/
Cursante <|.. Estudiante : implementa 

/'Para cuando conoce a "*" cantidad de esa clase'/
Estudiante "*" <-left- docente : conoce/tiene

/'Se usa cuando un objeto ES una clase'/
Estudiante <|-- lucia : es
Estudiante <|-- juan : es
Estudiante <|-- perla : es
Oyente <|-- unOyente : es

/'Se usa cuando un objeto lo recibe por par√°metro (es la m√°s d√©bil, es cuando algo queda medio desconexo)'/
Examen <.. docente : usa
 

/'
ver cuando se usa:

Implements: implementa una interfaz (comparte los mismos mensajes que otros, aprovechando el polimorfismo)
su flecha es ..|>

Extends: hereda de una clase
su flecha es --|>
'/



 

Herencia
Al tener l√≥gica repetida entre clases podemos crear una nueva clase con esa l√≥gica, dejando en cada una de las clases iniciales s√≥lo lo particular de cada una.
Super
Siguiendo con nuestro ejemplo, imagin√©monos que aparece la clase Gallina üêî, cada Gallina emite el sonido ‚ÄúA River lo sigo a donde va‚Äù y cuando juegan tambi√©n pierde energia, peeero tambi√©n ponen un huevo üê£. Entonces tendr√≠amos que redefinir el m√©todo jugar, pero teniendo en cuenta que una parte de la l√≥gica ya est√° definida en la superclase Animal. Para hacer esto vamos a combinar override (para redefinir un m√©todo de la superclase) con super (para ver que hace la superclase):
class Gallina inherits Animal(sonido = "A River lo sigo a donde va") {
	var huevosPuestos = 0

	override method jugar(unTiempo) {
	super(unTiempo)
	huevosPuestos ++
}
}
Podemos aprovechar super tanto para m√©todos que retornan algo (para obtener ese algo) como para m√©todos que no retornan nada (para ejecutar su comportamiento).
Redefinici√≥n
m√©todo abstracto escribiendo solo la firma de la siguiente manera:
class Animal {
	‚Ä¶.
	method recibirDue√±o()
	‚Ä¶.
}

‚ùó ‚ùó Es importante diferenciar recibirDue√±o() de recibirDue√±o() { }.
Si una clase tiene un m√©todo abstracto, esta no puede ser instanciada. En nuestro ejemplo podemos tener gallinas, gatos y perros pero no animales a secas.
Luego de hacer esto es importante redefinir el m√©todo en cada subclase con la palabra override:



class Gallina inherits Animal(sonido = "A River lo sigo a donde va") {
var huevosPuestos = 0

	override method jugar(unTiempo) {
	super(unTiempo)
	huevosPuestos ++
}

	override method recibirDue√±o() { 
	huevosPuestos = 0 /* el due√±o llega y le roba los huevos*/
}
}
Interfaces
Una interfaz es un contrato que cumplen dos o m√°s clases u objetos la cual obliga a que estos cumplan con la implementaci√≥n de un conjunto de m√©todos.
Cuando dos objetos o clases tienen una interfaz en com√∫n, es posible para un tercero utilizar sus instancias de forma polim√≥rfica, aunque recordemos que el polimorfismo solo est√° si efectivamente un tercero interact√∫a indistintamente con ellos.
Excepciones
es una indicaci√≥n de que algo sali√≥ mal en la ejecuci√≥n de nuestro programa.
‚Ä¢	Usando el mensaje error, el cual entienden los objetos y nos sirve para lanzar una excepci√≥n:
self.error("mensaje del error")
‚Ä¢	Usando throw y la clase Exception:
 throw new Exception(message = "mensaje del error")
Tambi√©n podemos crear nuestras propias excepciones . Para esto podemos crear una clase que herede de Exception. Esto nos va a ser √∫til m√°s adelante.:
class ExcepcionParticularDelPrograma inherits Exception {}
y la lanzamos como antes:
throw new ExcepcionParticularDelPrograma(message = "mensaje del error")
Adem√°s, es importante que nuestros mensajes de excepci√≥n sean expresivos. As√≠ si algo rompe  sabremos por qu√© .
Ahora, todo bien, pero ¬øpara qu√© me sirven en la ejecuci√≥n del programa? ¬øQu√© hacen?
class Summer inherits Beth{
  override method irseDeViaje(unRick) {
    if (self.esLunes()) {
      super(unRick)
    } else {
      throw new NoPuedoIrmeDeViajeException(message = "¬°S√≥lo puedo irme de aventura los lunes!")
    }
  }


}
Luego de tirar la excepci√≥n se corta la ejecuci√≥n del programa, por lo que si hab√≠a c√≥digo despu√©s, no ser√° ejecutado. Adem√°s, decimos que las excepciones burbujean por lo que si otro objeto manda un mensaje y ese m√©todo lanza la excepci√≥n, tambi√©n cortar√° el flujo de ejecuci√≥n para ese objeto.
Entonces, ¬øsi lanzamos una excepci√≥n esta subir√° indefinidamente? Bueno, en realidad no, porque si esto pasara cada vez que se lanza una excepci√≥n terminar√≠a nuestro programa. As√≠ que ahora veremos una forma de manejar excepciones‚Ä¶
Atrapando Excepciones
Cuando sabemos qu√© hacer ante una excepci√≥n, tenemos la opci√≥n de atrapar la excepci√≥n y utilizar otro c√≥digo que se tiene que ejecutar si ocurri√≥ tal excepci√≥n.  
En Wollok, esto se realiza de la siguiente forma:
try {
	// c√≥digo que puede fallar
} catch e : ExcepcionQueQuieroAtrapar {
	// c√≥digo a ejecutar si ocurre ExcepcionQueQuieroAtrapar
}
Algo a notar, es que la excepci√≥n a atrapar tiene que ser la que quiero atrapar y lo menos general posible. Si atrapo, por ejemplo, Exception, seguramente est√© atrapando errores que no hubiese querido atrapar como errores de que no se entiende el mensaje o la divisi√≥n por cero).

Herencia
Como ya hab√≠amos visto, la herencia la podemos utilizar cuando tenemos l√≥gica repetida entre distintos objetos, y queremos agruparla.
class JuegoViolento inherits Juego {
method jugar(unUsuario,unasHoras){
unUsuario.reducirHumor(10 * unasHoras)
}
}

class JuegoMOBA inherits Juego {
method jugar(unUsuario, unasHoras){
unUsuario.comprarSkins()
}
}

class JuegoDeTerror inherits Juego {
method jugar(unUsuario,unasHoras){
unUsuario.tirarTodoAlCarajo()
}
}

class JuegoDeEstrategia inherits Juego {
method jugar(unUsuario,unasHoras){
unUsuario.aumentarHumor(5 * unasHoras)
}
}

// Herencia
// Relaci√≥n est√°tica, no puede cambiar de clase
// Solo permite implementar un tipo
// Es m√°s simple
Composici√≥n
Podemos utilizar la composici√≥n. De esta manera, delegamos la l√≥gica de la suscripci√≥n a una nueva clase u objeto, la cual cada cliente conocer√° a una instancia de esta clase a trav√©s de un atributo:
class Usuario {
var suscripcion

method puedeJugar(unJuego) {
return suscripcion.permiteJugar(unJuego)
}


method actualizarSuscripcion(unaSuscripcion) {
suscripcion = unaSuscripcion
}

method pagarSuscripcion() {
if(self.leAlcanzaParaPagar(suscripcion.costo())) {
self.actualizarSuscripcion(prueba)
} else {
plataEnCuenta -= suscripcion.costo()
}
}
}
La composici√≥n es una soluci√≥n din√°mica, que nos ayuda a resolver este tipo de contextos.

// Composici√≥n
// Relaci√≥n din√°mica, si permite cambiar de tipo
// Implementar multiples tipos
// Es m√°s dif√≠cil
 
